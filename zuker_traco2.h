void zuker_traco2()
{

    int c1,c2,c3,c4,c5,c6,c7,c8,c9,c11,c10,c12,c13,c14,c15;




    for( c1 = 0; c1 <= floord(N - 1, 16); c1 += 1)
        for( c3 = 0; c3 <= min(c1, floord(N - 2, 16)); c3 += 1)
        {
            for( c5 = 0; c5 <= min(c3, floord(N - 4, 16)); c5 += 1)
            {
                for( c6 = max(0, -c1 + 1); c6 <= min(1, c3 - c5); c6 += 1)
                {
                    if (c6 == 1)
                    {
//          #pragma omp parallel for
                        for( c9 = max(-N + 16 * c1 + 1, -N + 16 * c3 + 2); c9 <= min(0, -N + 16 * c1 + 16); c9 += 1)
                        {
                            if (N + c9 >= 16 * c1 + 3)
                            {
                                for( c11 = 16 * c3 - c9 + 1; c11 <= 16 * c3 - c9 + 2; c11 += 1)
                                    for( c13 = 16 * c5 - c9 + 1; c13 <= 16 * c5 - c9 + 16; c13 += 1)
                                        W[(-c9)][c11] = MIN ( MIN(W[(-c9)][c13], W[c13+1][c11]), W[(-c9)][c11]);
                            }
                            else
                                for( c11 = 16 * c3 - c9 + 1; c11 <= min(N - 1, 16 * c3 - c9 + 16); c11 += 1)
                                    for( c13 = 16 * c5 - c9 + 1; c13 <= 16 * c5 - c9 + 16; c13 += 1)
                                        W[(-c9)][c11] = MIN ( MIN(W[(-c9)][c13], W[c13+1][c11]), W[(-c9)][c11]);
                        }
                    }
                    else
                        for( c7 = 0; c7 <= min(min(c1 - 1, c3 - c5), -c5 + (N - 4) / 16); c7 += 1)
                        {
                            if (c1 >= c3 + 1)
                                for( c11 = max(max(N - 16 * c1 + 16 * c3, N - 16 * c1 + 16 * c5 + 16 * c7 + 2), N - 16 * c1 + 16 * c7 + 3); c11 <= N - 16 * c1 + 16 * c3 + 15; c11 += 1)
                                    for( c15 = N - 16 * c1 + 16 * c5 + 16 * c7 + 1; c15 <= min(min(N - 16 * c1 + 16 * c5 + 16 * c7 + 16, 16 * c5 + c11 - 2), c11 - 1); c15 += 1)
                                        V[(N-16*c1-1)][c11] = MIN(V[(N-16*c1+16*c5)][c15] + EFL[(N-16*c1-1)][c11], V[(N-16*c1-1)][c11]);
                            if (c3 >= c7 + 1)
//              #pragma omp parallel for
                                for( c9 = max(-N + 16 * c1 + 2, -N + 16 * c5 + 16 * c7 + 4); c9 <= min(0, -N + 16 * c1 + 16); c9 += 1)
                                {
                                    for( c11 = max(16 * c3 - c9 + 1, 16 * c5 + 16 * c7 - c9 + 3); c11 <= min(N - 1, 16 * c3 - c9 + 3); c11 += 1)
                                        for( c15 = 16 * c5 + 16 * c7 - c9 + 2; c15 <= min(min(16 * c5 + 16 * c7 - c9 + 17, 16 * c5 + c11 - 2), c11 - 1); c15 += 1)
                                            V[(-c9)][c11] = MIN(V[(16*c5-c9+1)][c15] + EFL[(-c9)][c11], V[(-c9)][c11]);
                                    if (c5 == 0)
                                        for( c11 = 16 * c3 - c9 + 4; c11 <= min(N - 1, 16 * c3 - c9 + 16); c11 += 1)
                                            for( c15 = 16 * c7 - c9 + 2; c15 <= 16 * c7 - c9 + 17; c15 += 1)
                                                V[(-c9)][c11] = MIN(V[(-c9+1)][c15] + EFL[(-c9)][c11], V[(-c9)][c11]);
                                }
                        }
                }
//      #pragma omp parallel for
                for( c9 = max(max(-N + 16 * c1 + 1, -N + 16 * c3 + 2), -N + 16 * c5 + 4); c9 <= min(0, -N + 16 * c1 + 16); c9 += 1)
                {
                    if (N + c9 >= 16 * c1 + 2)
                    {
                        for( c11 = max(16 * c3 - c9 + 1, 16 * c5 - c9 + 3); c11 <= min(N - 1, 16 * c3 - c9 + 3); c11 += 1)
                            for( c13 = 16 * c5 - c9 + 1; c13 <= min(16 * c5 - c9 + 16, c11 - 2); c13 += 1)
                            {
                                if (c9 + c13 >= 16 * c5 + 2)
                                    for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                        V[(-c9)][c11] = MIN(V[c13][c15] + EFL[(-c9)][c11], V[(-c9)][c11]);
                                V[(-c9)][c11] = MIN(W[(-c9)+1][c13] + W[c13+1][c11-1], V[(-c9)][c11]);
                            }
                    }
                    else
                        for( c11 = max(N - 16 * c1 + 16 * c3, N - 16 * c1 + 16 * c5 + 2); c11 <= N - 16 * c1 + 16 * c3 + 15; c11 += 1)
                        {
                            if (c5 == 0)
                                for( c13 = N - 16 * c1; c13 < -16 * c3 + c11 - 2; c13 += 1)
                                {
                                    if (16 * c1 + c13 >= N + 1)
                                        for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                            V[(N-16*c1-1)][c11] = MIN(V[c13][c15] + EFL[(N-16*c1-1)][c11], V[(N-16*c1-1)][c11]);
                                    V[(N-16*c1-1)][c11] = MIN(W[(N-16*c1-1)+1][c13] + W[c13+1][c11-1], V[(N-16*c1-1)][c11]);
                                }
                            for( c13 = max(N - 16 * c1 + 16 * c5, -16 * c3 + c11 - 2); c13 <= min(N - 16 * c1 + 16 * c5 + 15, c11 - 2); c13 += 1)
                            {
                                if (c5 == 0 && 16 * c1 + c11 >= N + 16 * c3 + 3 && 16 * c3 + c13 + 2 == c11)
                                {
                                    for( c15 = -16 * c3 + c11 - 1; c15 < c11; c15 += 1)
                                        V[(N-16*c1-1)][c11] = MIN(V[(-16*c3+c11-2)][c15] + EFL[(N-16*c1-1)][c11], V[(N-16*c1-1)][c11]);
                                }
                                else if (16 * c1 + c13 >= N + 16 * c5 + 1 && 16 * c3 + c13 + 1 >= c11)
                                    for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                        V[(N-16*c1-1)][c11] = MIN(V[c13][c15] + EFL[(N-16*c1-1)][c11], V[(N-16*c1-1)][c11]);
                                V[(N-16*c1-1)][c11] = MIN(W[(N-16*c1-1)+1][c13] + W[c13+1][c11-1], V[(N-16*c1-1)][c11]);
                            }
                        }
                }
            }
            for( c4 = 1; c4 <= 2; c4 += 1)
            {
                if (c3 == c1 && c4 == 2)
                {
//        #pragma omp parallel for
                    for( c9 = -N + 16 * c1 + 2; c9 <= min(0, -N + 16 * c1 + 4); c9 += 1)
                        for( c11 = 16 * c1 - c9 + 1; c11 < N; c11 += 1)
                        {
                            if (c9 + c11 >= 16 * c1 + 2)
                            {
                                if (N + c9 == 16 * c1 + 4 && c11 + 1 == N)
                                {
                                    for( c13 = N - 16 * c1 - 3; c13 < N - 1; c13 += 1)
                                        W[(N-16*c1-4)][(N-1)] = MIN ( MIN(W[(N-16*c1-4)][c13], W[c13+1][(N-1)]), W[(N-16*c1-4)][(N-1)]);
                                }
                                else if (N + c9 == 16 * c1 + 3 && c11 + 1 == N)
                                {
                                    W[(N-16*c1-3)][(N-1)] = MIN ( MIN(W[(N-16*c1-3)][(N-2)], W[(N-2)+1][(N-1)]), W[(N-16*c1-3)][(N-1)]);
                                }
                                else
                                    W[(N-16*c1-4)][(N-2)] = MIN ( MIN(W[(N-16*c1-4)][(N-3)], W[(N-3)+1][(N-2)]), W[(N-16*c1-4)][(N-2)]);
                            }
                            W[(-c9)][c11] = MIN( MIN ( MIN ( W[(-c9)+1][c11], W[(-c9)][c11-1]), V[(-c9)][c11]), W[(-c9)][c11]);
                        }
                }
                else if (c1 >= c3 + 1 && c4 == 2)
                    for( c11 = N - 16 * c1 + 16 * c3; c11 <= N - 16 * c1 + 16 * c3 + 15; c11 += 1)
                    {
                        for( c13 = N - 16 * c1 + 16 * c3; c13 < c11; c13 += 1)
                            W[(N-16*c1-1)][c11] = MIN ( MIN(W[(N-16*c1-1)][c13], W[c13+1][c11]), W[(N-16*c1-1)][c11]);
                        W[(N-16*c1-1)][c11] = MIN( MIN ( MIN ( W[(N-16*c1-1)+1][c11], W[(N-16*c1-1)][c11-1]), V[(N-16*c1-1)][c11]), W[(N-16*c1-1)][c11]);
                    }
//      #pragma omp parallel for
                for( c9 = max(-N + 16 * c3 + 3 * c4 - 1, -N + 16 * c1 + c4); c9 <= min(0, -N + 16 * c1 + 15 * c4 - 14); c9 += 1)
                {
                    if (c4 == 2)
                        for( c11 = 16 * c3 - c9 + 1; c11 <= 16 * c3 - c9 + 3; c11 += 1)
                        {
                            if (c9 + c11 >= 16 * c3 + 2)
                            {
                                if (c9 + c11 == 16 * c3 + 2)
                                {
                                    W[(-c9)][(16*c3-c9+2)] = MIN ( MIN(W[(-c9)][(16*c3-c9+1)], W[(16*c3-c9+1)+1][(16*c3-c9+2)]), W[(-c9)][(16*c3-c9+2)]);
                                }
                                else if (N + c9 >= 16 * c1 + 3)
                                {
                                    for( c13 = -c9 + 1; c13 <= 16 * c3 - c9 + 2; c13 += 1)
                                        W[(-c9)][(16*c3-c9+3)] = MIN ( MIN(W[(-c9)][c13], W[c13+1][(16*c3-c9+3)]), W[(-c9)][(16*c3-c9+3)]);
                                }
                                else
                                    for( c13 = N - 16 * c1 + 16 * c3 - 1; c13 <= N - 16 * c1 + 16 * c3; c13 += 1)
                                        W[(N-16*c1-2)][(N-16*c1+16*c3+1)] = MIN ( MIN(W[(N-16*c1-2)][c13], W[c13+1][(N-16*c1+16*c3+1)]), W[(N-16*c1-2)][(N-16*c1+16*c3+1)]);
                            }
                            W[(-c9)][c11] = MIN( MIN ( MIN ( W[(-c9)+1][c11], W[(-c9)][c11-1]), V[(-c9)][c11]), W[(-c9)][c11]);
                        }
                    for( c11 = 16 * c3 + 3 * c4 - c9 - 2; c11 <= min(N - 1, 16 * c3 - c9 + 16); c11 += 1)
                        for( c12 = max(0, -N + 16 * c1 - c9 + 2); c12 <= min(2, N - 16 * c1 + c9); c12 += 1)
                        {
                            if (c12 >= 1)
                            {
                                if (c12 == 1)
                                {
                                    V[(-c9)][c11] = MIN( MIN (V[(-c9)+1][c11-1], EHF[(-c9)][c11]), V[(-c9)][c11]);
                                }
                                else
                                    W[(-c9)][c11] = MIN( MIN ( MIN ( W[(-c9)+1][c11], W[(-c9)][c11-1]), V[(-c9)][c11]), W[(-c9)][c11]);
                            }
                            else if (N + c9 >= 16 * c1 + 3)
                            {
                                for( c13 = -c9 + 1; c13 < c11; c13 += 1)
                                    for( c14 = max(max(0, -c11 + c13 + 2), 5 * c3 - c9 - c13 - (-c3 + c9 + c11 + 2) / 3 + 4); c14 <= min(2, c11 - c13); c14 += 1)
                                    {
                                        if (c14 >= 1)
                                        {
                                            if (c14 == 2)
                                            {
                                                V[(-c9)][c11] = MIN(W[(-c9)+1][c13] + W[c13+1][c11-1], V[(-c9)][c11]);
                                            }
                                            else
                                                W[(-c9)][c11] = MIN ( MIN(W[(-c9)][c13], W[c13+1][c11]), W[(-c9)][c11]);
                                        }
                                        else if (c9 + c13 >= 2)
                                        {
                                            for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                                V[(-c9)][c11] = MIN(V[c13][c15] + EFL[(-c9)][c11], V[(-c9)][c11]);
                                        }
                                        else
                                            for( c15 = 16 * c3 - c9 + 5; c15 < c11 - 1; c15 += 1)
                                                V[(-c9)][c11] = MIN(V[(-c9+1)][c15] + EFL[(-c9)][c11], V[(-c9)][c11]);
                                    }
                            }
                            else
                                for( c13 = N - 16 * c1 + 16 * c3 - 1; c13 < c11; c13 += 1)
                                    for( c14 = max(max(0, -c11 + c13 + 2), -8 * c1 + 8 * c3 - c13 + (N + c13) / 2 + 1); c14 <= min(min(2, c11 - c13), -N + 16 * c1 - 16 * c3 + c13 + 2); c14 += 1)
                                    {
                                        if (c14 >= 1)
                                        {
                                            if (c14 == 2)
                                            {
                                                V[(N-16*c1-2)][c11] = MIN(W[(N-16*c1-2)+1][c13] + W[c13+1][c11-1], V[(N-16*c1-2)][c11]);
                                            }
                                            else
                                                W[(N-16*c1-2)][c11] = MIN ( MIN(W[(N-16*c1-2)][c13], W[c13+1][c11]), W[(N-16*c1-2)][c11]);
                                        }
                                        else
                                            for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                                V[(N-16*c1-2)][c11] = MIN(V[c13][c15] + EFL[(N-16*c1-2)][c11], V[(N-16*c1-2)][c11]);
                                    }
                        }
                }
                if (c4 == 1)
//        #pragma omp parallel for
                    for( c9 = -N + 16 * c1 + 2; c9 <= min(0, -N + 16 * c1 + 16); c9 += 1)
                        for( c11 = 16 * c3 - c9 + 1; c11 <= min(N - 1, 16 * c3 - c9 + 16); c11 += 1)
                        {
                            int c12 = c9 + c11 >= 16 * c3 + 4 ? 0 : 1;
                            if (N + c9 >= 16 * c1 + 3)
                                for( c15 = 16 * c3 - c9 + 2; c15 <= min(16 * c3 - c9 + 4, c11 - 2); c15 += 1)
                                    V[(-c9)][c11] = MIN(V[(-c9+1)][c15] + EFL[(-c9)][c11], V[(-c9)][c11]);
                            if (c12 == 1)
                            {
                                V[(-c9)][c11] = MIN( MIN (V[(-c9)+1][c11-1], EHF[(-c9)][c11]), V[(-c9)][c11]);
                            }
                            else if (N + c9 == 16 * c1 + 2)
                                for( c13 = N - 16 * c1 - 1; c13 <= N - 16 * c1 + 16 * c3; c13 += 1)
                                {
                                    if (16 * c1 + c13 + 1 == N)
                                    {
                                        for( c15 = N - 16 * c1 + 16 * c3; c15 < c11 - 1; c15 += 1)
                                            V[(N-16*c1-2)][c11] = MIN(V[(N-16*c1-1)][c15] + EFL[(N-16*c1-2)][c11], V[(N-16*c1-2)][c11]);
                                    }
                                    else
                                        for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                            V[(N-16*c1-2)][c11] = MIN(V[c13][c15] + EFL[(N-16*c1-2)][c11], V[(N-16*c1-2)][c11]);
                                    if (N + 16 * c3 >= 16 * c1 + c13 + 1)
                                        V[(N-16*c1-2)][c11] = MIN(W[(N-16*c1-2)+1][c13] + W[c13+1][c11-1], V[(N-16*c1-2)][c11]);
                                }
                        }
            }
        }


    if(1==0)
        for( c1 = 1; c1 < N + floord(N - 2, 96); c1 += 1)
            #pragma omp parallel for
            for( c3 = max(0, -N + c1 + 1); c3 <= (c1 - 1) / 97; c3 += 1)
            {
                for( c5 = 0; c5 <= min(8 * c3 + 7, floord(c1 - c3 - 3, 12)); c5 += 1)
                {
                    for( c7 = 0; c7 <= min(min(8 * c3 - c5 + 7, floord(c1 - c3 - 4, 12)), -c5 + (c1 - c3 - 3) / 12); c7 += 1)
                        for( c11 = max(max(N - c1 + 97 * c3, N - c1 + c3 + 12 * c5 + 12 * c7 + 2), N - c1 + c3 + 12 * c7 + 3); c11 <= min(N - 1, N - c1 + 97 * c3 + 95); c11 += 1)
                            for( c15 = N - c1 + c3 + 12 * c5 + 12 * c7 + 1; c15 <= min(min(N - c1 + c3 + 12 * c5 + 12 * c7 + 12, 12 * c5 + c11 - 2), c11 - 1); c15 += 1)
                                V[(N-c1+c3-1)][c11] = MIN(V[(N-c1+c3+12*c5)][c15] + EFL[(N-c1+c3-1)][c11], V[(N-c1+c3-1)][c11]);
                    for( c6 = max(1, -c3 + c5 / 8 + 2); c6 <= 2; c6 += 1)
                    {
                        if (c6 == 2)
                        {
                            for( c11 = max(N - c1 + 97 * c3, N - c1 + c3 + 12 * c5 + 2); c11 <= min(N - 1, N - c1 + 97 * c3 + 95); c11 += 1)
                                for( c13 = N - c1 + c3 + 12 * c5; c13 <= min(N - c1 + c3 + 12 * c5 + 11, c11 - 2); c13 += 1)
                                {
                                    if (c1 + c13 >= N + c3 + 12 * c5 + 1)
                                        for( c15 = c13 + 1; c15 < c11; c15 += 1)
                                            V[(N-c1+c3-1)][c11] = MIN(V[c13][c15] + EFL[(N-c1+c3-1)][c11], V[(N-c1+c3-1)][c11]);
                                    V[(N-c1+c3-1)][c11] = MIN(W[(N-c1+c3-1)+1][c13] + W[c13+1][c11-1], V[(N-c1+c3-1)][c11]);
                                }
                        }
                        else
                            for( c11 = N - c1 + 97 * c3; c11 <= min(N - 1, N - c1 + 97 * c3 + 95); c11 += 1)
                                for( c13 = N - c1 + c3 + 12 * c5; c13 <= N - c1 + c3 + 12 * c5 + 11; c13 += 1)
                                    W[(N-c1+c3-1)][c11] += MIN ( MIN(W[(N-c1+c3-1)][c13], W[c13+1][c11]), W[(N-c1+c3-1)][c11]);
                    }
                }
                for( c4 = 1; c4 <= 2; c4 += 1)
                    for( c11 = N - c1 + 97 * c3; c11 <= min(N - 1, N - c1 + 97 * c3 + 95); c11 += 1)
                    {
                        if (c4 == 2)
                            for( c13 = N - c1 + 97 * c3; c13 < c11; c13 += 1)
                                W[(N-c1+c3-1)][c11] += MIN ( MIN(W[(N-c1+c3-1)][c13], W[c13+1][c11]), W[(N-c1+c3-1)][c11]);
                        {
                            if( c4+23 == 16 ) V[(N-c1+c3-1)][c11] = MIN(V[0][0] + EFL[(N-c1+c3-1)][c11], V[(N-c1+c3-1)][c11]);
                            if( c4+23 == 19 ) W[(N-c1+c3-1)][c11] += MIN ( MIN(W[(N-c1+c3-1)][0], W[0+1][c11]), W[(N-c1+c3-1)][c11]);
                            if( c4+23 == 21 ) V[(N-c1+c3-1)][c11] = MIN(W[(N-c1+c3-1)+1][0] + W[0+1][c11-1], V[(N-c1+c3-1)][c11]);
                            if( c4+23 == 24 ) V[(N-c1+c3-1)][c11] = MIN( MIN (V[(N-c1+c3-1)+1][c11-1], EHF[(N-c1+c3-1)][c11]), V[(N-c1+c3-1)][c11]);
                            if( c4+23 == 25 ) W[(N-c1+c3-1)][c11] = MIN( MIN ( MIN ( W[(N-c1+c3-1)+1][c11], W[(N-c1+c3-1)][c11-1]), V[(N-c1+c3-1)][c11]), W[(N-c1+c3-1)][c11]);
                        }
                    }
            }

}
